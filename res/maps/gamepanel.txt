import java.awt.*;
import java.awt.image.*;
import javax.swing.*;

public class GamePanel extends JPanel {
    // map
    public final int tileSize = 32;
    public final int gamePanelSizeX = 800;
    public final int gamePanelSizeY = 600;
    public int mapX = 13*32;
    public int mapY = 13*32;
    @SuppressWarnings("unused")
    private final int scaleMultiplier = 2;
    public BufferedImage grassTile;
    public BufferedImage tree1;
    PlayerStatus ps = new PlayerStatus(this);
    public int speed = 5;
    public int whatFrame = 0;
    public final int frameSpeed = 3; // higher = slower animation
    public int frameDelay = 0; // counts frames for delay
    public int playerX = 0;
    public int playerY = 0;
    public int playerXCollision = playerX;
    public int playerYCollision = (playerY-tileSize);
    // tile
    public int tileRow = 50; // rows of grid
    public int tileCol = 50; // columns of grid
    public int baseLayerGrid[][] = new int[tileRow][tileCol];
    public int objectLayerGrid[][] = new int[tileRow][tileCol];
    tilesManager tiles = new tilesManager(this);
    // collisions
    String playerDirection = "";
    Collisions playerCollision;
    Collisions tree1Collision;
    Collisions borderCollision;
    Collisions rockCollision;
    Collisions structureCollision;

    public void entitiesCollision() {
        // playerCollision = new Collisions(playerX + 15, playerY, ps.playerSizeW / 2, ps.playerSizeH/2);
        playerCollision = new Collisions(playerX, playerY, ps.playerSizeW, ps.playerSizeH);
        
        tree1Collision = new Collisions(-64, -64, tileSize, tileSize);
        borderCollision = new Collisions(0, 0, 0, 0);
        //rockCollision = new Collisions(0, 0, tileSize, tileSize);
        //structureCollision = new Collisions(0, 0, tileSize * 2, tileSize * 2);
    }

    public GamePanel() {
        loadSprites();
        KeyHandler keyH = new KeyHandler(this);
        this.setFocusable(true);
        this.addKeyListener(keyH);
        this.setPreferredSize(new Dimension(gamePanelSizeX, gamePanelSizeY));
        this.setBackground(Color.gray);
        keyH.startGameLoop();
        playerX = (gamePanelSizeX-ps.playerSizeW)/2;
        playerY = (gamePanelSizeY-ps.playerSizeH)/2;
    };

    // character movement
    public void moveUp() {
        // map border collision
        playerDirection = "up";
        int alphaThreshold = 5;
        Rectangle inter = ps.bbox.intersection(tree1Collision); //| ps.bbox.intersection(borderCollision);
        if (inter.isEmpty()) {mapY -= speed;}
        else{
            int startAX = inter.x - ps.bbox.x;
            int startAY = inter.y - ps.bbox.y;
            int startBX = inter.x - tree1Collision.x;
            int startBY = inter.y - tree1Collision.y;

            for (int y = 0; y < inter.height; y++) {
                for (int x = 0; x < inter.width; x++) {
                    int rgbA = ps.currentImage.getRGB(startAX + x, startAY + y);
                    int rgbB = tiles.tree1.getRGB(startBX + x, startBY + y);
                    int alphaA = (rgbA >>> 24) & 0xff;
                    int alphaB = (rgbB >>> 24) & 0xff;
                    if (alphaA > alphaThreshold && alphaB > alphaThreshold) {
                        System.out.println("Collision Detected");
                    }
                }
            }
        }
//         if (ps.bbox.intersects(tree1Collision) || ps.bbox.intersects(borderCollision)) {
//             System.out.println("Collision Detected");
//         } else {
// a            mapY -= speed;
//         }
        frameDelay++;
        if (frameDelay >= frameSpeed) {
            whatFrame = (whatFrame + 1) % 4;
            ps.currentImage = ps.upAnimation[whatFrame];
            frameDelay = 0;
        }

        repaint();
    }

    public void moveDown() {
        playerDirection = "down";
        if (playerCollision.intersects(tree1Collision) || playerCollision.intersects(borderCollision)) {
            System.out.println("Collision Detected");
        } else {
            mapY += speed;
        }

        frameDelay++;
        if (frameDelay >= frameSpeed) {
            whatFrame = (whatFrame + 1) % 4;
            ps.currentImage = ps.downAnimation[whatFrame];
            frameDelay = 0;
        }

        repaint();
    }

    public void moveLeft() {
        playerDirection = "left";
        if (playerCollision.intersects(tree1Collision) || playerCollision.intersects(borderCollision)) {
            System.out.println("Collision Detected");
        } else {
            mapX -= speed;
        }
        frameDelay++;
        if (frameDelay >= frameSpeed) {
            whatFrame = (whatFrame + 1) % 4;
            ps.currentImage = ps.leftAnimation[whatFrame];
            frameDelay = 0;
        }
        repaint();
    }

    public void moveRight() {
        playerDirection = "right";
        if (playerCollision.intersects(tree1Collision)) {
            System.out.println("Collision Detected");
        } else {
            mapX += speed;
        }
        frameDelay++;
        if (frameDelay >= frameSpeed) {
            whatFrame = (whatFrame + 1) % 4;
            ps.currentImage = ps.rightAnimation[whatFrame];
            frameDelay = 0;
        }
        repaint();
    }

    public void setSpeed(int speed) {
        this.speed = speed;
    }

    // sprite
    @SuppressWarnings({ "CallToPrintStackTrace", "UseSpecificCatch" })
    private void loadSprites() {
        System.out.println("playerSizeW: " + ps.playerSizeW);
        System.out.println("playerSizeH: " + ps.playerSizeH);
        System.out.println("playerX: " + playerX);
        System.out.println("playerY: " + playerY);
        try {
            System.out.println("Map Width: " + tileCol * tileSize);
            System.out.println("Map Height: " + tileRow * tileSize);
            System.out.println("MapX: " + mapX);
            System.out.println("MapY: " + mapY);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        tiles.draw(g);
        ps.draw(g);
        //gridLines
        //for (int x = 0; x < (tileRow * tileSize); x += tileSize) {
        //    g.setColor(Color.red); // Vertical lines
        //    g.drawLine(x - mapX, 0 - mapY, x - mapX, (tileCol * tileSize) - mapY);
        //}
        //for (int y = 0; y <= (tileCol * tileSize); y += tileSize) {
        //    g.setColor(Color.red);// Horizontal lines
        //    g.drawLine(0 - mapX, y - mapY, (tileCol * tileSize) - mapX, y - mapY); 
        //}
        //g.setColor(Color.green);
        //g.drawLine(0, gamePanelSizeY / 2, gamePanelSizeX, gamePanelSizeY / 2);
        //g.setColor(Color.green);
        //g.drawLine(gamePanelSizeX / 2, gamePanelSizeY, gamePanelSizeX / 2, 0);
        
        ////grid coordinates
        //g.setColor(Color.white);
        //for (int row = 0; row < tileCol; row++) {
        //    for (int col = 0; col < tileRow; col++) {
        //        int drawX = (col * tileSize) - mapX;
        //        int drawY = (row * tileSize) - mapY + 1;
        //        g.setColor(Color.white);
        //        g.drawString(col+","+row, drawX, drawY);
        //    }
        //}
    }
}